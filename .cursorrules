# Mainote Bot - Cursor Rules & Instructions

## Project Overview
This is a Telegram bot that saves notes to Notion with voice message support, daily morning notifications, and multilingual support (Russian primary). The bot integrates Telegram, Notion API, OpenAI Whisper, and includes timezone-aware scheduling.

## Architecture & Patterns

### Project Structure
```
mainote_bot/
├── bot/                  # Telegram handlers
│   ├── commands.py       # Command handlers (/start, /help, etc.)
│   ├── callbacks.py      # Inline keyboard callbacks
│   └── messages.py       # Text/voice message handlers
├── notion/               # Notion API integration
│   ├── client.py         # Notion client wrapper
│   └── tasks.py          # Task management functions
├── scheduler/            # Notification scheduling
│   ├── notifications.py  # Morning notification logic
│   └── time_utils.py     # Timezone utilities
├── webhook/              # FastAPI webhook handlers
│   ├── routes.py         # HTTP routes
│   └── setup.py          # Webhook configuration
├── utils/                # Shared utilities
│   └── logging.py        # Centralized logging
├── config.py             # Environment configuration
├── database.py           # PostgreSQL database operations
├── user_preferences.py   # User settings management
└── main.py              # Application entry point
```

## Coding Standards

### General Guidelines
- **Language**: Primary language is Russian for user-facing messages, English for code comments
- **Error Handling**: Always wrap async operations in try-catch blocks with detailed logging
- **Logging**: Use the centralized logger from `mainote_bot.utils.logging`
- **Type Hints**: Always include type hints for function parameters and return values
- **Async/Await**: All bot handlers and external API calls must be async

### Code Style
- Follow PEP 8 for Python code formatting
- Use descriptive variable names in English
- Keep functions focused and single-purpose
- Prefer composition over inheritance

## Key Patterns to Follow

### 1. Telegram Handler Pattern
```python
async def command_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle the /command_name command."""
    try:
        chat_id = update.effective_chat.id
        # Handler logic here
        logger.info(f"Handled command for {chat_id}")
    except Exception as e:
        logger.error(f"Error in command_name: {str(e)}", exc_info=True)
        await context.bot.send_message(
            chat_id=update.effective_chat.id,
            text="Произошла ошибка. Попробуйте позже."
        )
```

### 2. Notion API Integration Pattern
```python
async def notion_operation():
    """Perform Notion API operation with error handling."""
    try:
        client = get_notion_client()
        # API operation here
        return result
    except Exception as e:
        logger.error(f"Notion API error: {str(e)}", exc_info=True)
        raise
```

### 3. Database Operation Pattern
```python
async def db_operation():
    """Database operation with proper connection handling."""
    conn = None
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Database operations here
        conn.commit()
        return result
    except Exception as e:
        if conn:
            conn.rollback()
        logger.error(f"Database error: {str(e)}", exc_info=True)
        raise
    finally:
        if conn:
            conn.close()
```

### 4. Callback Handler Pattern
```python
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle inline keyboard callbacks."""
    try:
        query = update.callback_query
        await query.answer()  # Always acknowledge callback
        
        data = query.data
        chat_id = query.message.chat_id
        
        # Process callback data
        
        await query.edit_message_text(text="Response message")
        logger.info(f"Processed callback {data} for {chat_id}")
    except Exception as e:
        logger.error(f"Callback error: {str(e)}", exc_info=True)
```

## Configuration Management

### Environment Variables
- Always use `config.py` for environment variable access
- Provide sensible defaults where appropriate
- Document all required environment variables

### Required Environment Variables:
```
TELEGRAM_BOT_TOKEN       # Telegram bot token
NOTION_API_KEY          # Notion integration API key
NOTION_DATABASE_ID      # Notion database ID
OPENAI_API_KEY          # OpenAI API key for Whisper
WEBHOOK_URL             # Public webhook URL
MORNING_NOTIFICATION_TIME # Default: "08:00"
NOTIFICATION_CHAT_IDS   # Comma-separated chat IDs
ENABLE_MORNING_NOTIFICATIONS # "true" or "false"
SENTRY_DSN              # Optional: Sentry error tracking
```

## Specific Implementation Guidelines

### Telegram Bot Development
- Always validate `update.effective_chat.id` before operations
- Use `InlineKeyboardMarkup` for interactive buttons
- Implement proper callback query handling with `await query.answer()`
- Support both text and voice messages
- Handle user permissions and error states gracefully

### Notion Integration
- Use the official `notion-client` library
- Implement proper retry logic for API calls
- Handle rate limiting (3 requests per second)
- Map Notion properties correctly according to `NOTION_DB_SCHEMA`

### Scheduling & Notifications
- Use timezone-aware datetime operations
- Support user-specific timezone preferences
- Implement proper UTC conversion
- Use `apscheduler` for reliable scheduling
- Handle notification failures gracefully

### Database Operations
- Use PostgreSQL for consistent data storage
- Implement proper connection pooling
- Always use parameterized queries to prevent SQL injection
- Handle database migration scenarios

### Error Handling
- Log all errors with full context using `exc_info=True`
- Provide user-friendly error messages in Russian
- Implement proper fallback behaviors
- Use Sentry for production error tracking

### Testing Guidelines
- Write unit tests for core business logic
- Mock external API calls (Telegram, Notion, OpenAI)
- Test timezone handling with different user timezones
- Test error scenarios and edge cases

## File-Specific Guidelines

### `bot/commands.py`
- Each command should have comprehensive error handling
- Log all user interactions for debugging
- Support command arguments where appropriate
- Implement proper authorization for admin commands

### `bot/callbacks.py`
- Always acknowledge callback queries immediately
- Parse callback data safely with validation
- Update message content appropriately
- Handle concurrent callback processing

### `notion/client.py` & `notion/tasks.py`
- Implement proper API rate limiting
- Cache frequently accessed data
- Handle Notion API errors gracefully
- Support batch operations where possible

### `scheduler/notifications.py`
- Support user-specific notification preferences
- Handle timezone conversions correctly
- Implement notification delivery retry logic
- Log notification success/failure events

### `webhook/routes.py`
- Validate webhook signatures if required
- Handle high-volume webhook requests
- Implement proper request/response logging
- Support webhook health checks

## Deployment Considerations

### Docker
- Use multi-stage builds for smaller images
- Properly handle environment variables
- Include health check endpoints
- Optimize for production deployment

### Fly.io Deployment
- Configure proper resource allocation
- Set up persistent volumes if needed
- Handle graceful shutdowns
- Monitor application performance

## Security Guidelines

### API Security
- Never log sensitive information (tokens, API keys)
- Validate all user input
- Implement proper rate limiting
- Use HTTPS for all external communications

### Data Privacy
- Store minimal user data
- Implement proper data retention policies
- Handle GDPR compliance if applicable
- Secure database access

## Performance Optimization

### Bot Performance
- Use connection pooling for database operations
- Implement proper caching strategies
- Optimize database queries
- Handle concurrent user requests efficiently

### Memory Management
- Clean up resources properly
- Avoid memory leaks in long-running processes
- Monitor memory usage in production
- Implement proper garbage collection

## Development Workflow

### Code Organization
- Keep related functionality in appropriate modules
- Maintain clear separation of concerns
- Use consistent naming conventions
- Document complex business logic

### Version Control
- Write descriptive commit messages
- Use semantic versioning for releases
- Maintain clean commit history
- Include migration scripts when needed

This file should guide you in maintaining consistency with the existing codebase patterns and architecture decisions. 